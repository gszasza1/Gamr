import 'dart:math';
import 'dart:ui';

import 'package:gamr/models/database/points.dart';
import 'package:gamr/models/drawer/distance.dart';
import 'package:gamr/models/drawer/point.dart';

class DotList {
  /// List containing real dots
  List<Dot> allDots = [];

  /// List for drawable dots. AUTOGENERATED
  List<Dot> drawAbleDots = [];

  /// List for distance dots. AUTOGENERATED
  List<Distance> distances = [];

  /// List for distance dots 3D. AUTOGENERATED
  List<Distance> distances3D = [];

  /// List for height variation. AUTOGENERATED
  List<Distance> zHeightVariationList = [];

  double totalDegree = 0;
  double averageY = 0;
  double averageDrawY = 0;
  Paint graphPaint = Paint();

  double offsetX = 0;
  double offsetY = 0;

  double movableScale = 0;
  double scale = 10;

  double movableOffsetX = 0;
  double movableOffsetY = 0;

  double sliderX = 10;
  double sliderY = 10;

  void setNewFixOffset() {
    final scale = getScale();
    this.offsetX -= movableOffsetX / (sliderX / 10 * scale);
    this.offsetY -= movableOffsetY / (sliderX / 10 * scale);
    this.scale += movableScale;
    this.movableOffsetX = 0;
    this.movableOffsetY = 0;
  }

  double getXOffset() {
    return this.offsetX - this.movableOffsetX;
  }

  List<DBPoint> dotsToDBPoint() {
    return this
        .allDots
        .map((e) => DBPoint(x: e.x, y: e.y, z: e.z, name: e.name))
        .toList();
  }

  double getScale() {
    return pow(1.4, this.scale + this.movableScale).toDouble();
  }

  double getYOffset() {
    return this.offsetY - this.movableOffsetY;
  }

  void addDot(Dot point) {
    allDots.add(point);
    calculateMetadata();
  }

  void calculateMetadata() {
    calculateAverageY();
    recalculateDrawable();
    calculateDegree();
    generateNewDistances(false);
    if (drawAbleDots.length < 3 && drawAbleDots.length > 0) {
      this.calculateInitialOffset();
    }
  }

  void calculateInitialOffset() {
    if (allDots.length > 0) {
      this.offsetY = allDots[0].dy + 5;
      this.offsetX = -allDots[0].dx + 5;
      recalculateDrawable();
    }
  }

  void recalculateDrawable() {
    if (this.allDots.length > 0) {
      final scale = getScale();
      this.drawAbleDots = allDots
          .map((x) => Dot(
              (x.dx + this.offsetX) * sliderX / 10 * scale - movableOffsetX,
              (-x.dy + this.offsetY) * sliderY / 10 * scale - movableOffsetY))
          .toList();
    }
    calculateAverageDrawY();
  }

  void generateNewDistances(bool useDistance) {
    List<Distance> temp = [];
    List<Distance> temp3D = [];
    for (var i = 0; i < allDots.length - 1; i++) {
      double distance = 0;
      double distance3D = 0;
      if (!useDistance || this.distances.length == 0) {
        distance = allDots[i].distanceFromDot(allDots[i + 1]);
        distance3D = allDots[i].distanceFromDot3D(allDots[i + 1]);
      } else {
        distance = this.distances[i].distance;
        distance3D = this.distances3D[i].distance;
      }
      var dx = (this.drawAbleDots[i].dx + this.drawAbleDots[i + 1].dx) / 2;
      var dy = (this.drawAbleDots[i].dy + this.drawAbleDots[i + 1].dy) / 2;
      Distance tempDist = Distance(dx, dy, distance, true);
      Distance tempDist3D = Distance(dx, dy, distance3D, true);
      temp.add(tempDist);
      temp3D.add(tempDist3D);
    }
    this.distances = temp;
    this.distances3D = temp3D;
    this.generateHeightVariationList();
  }

  void generateHeightVariationList() {
    List<Distance> temp = [];
    for (var i = 0; i < allDots.length - 1; i++) {
      double distance = 0;
      if (this.distances.length > 1) {
        distance = allDots[i].z - allDots[i + 1].z;
        var dx = (this.drawAbleDots[i].dx + this.drawAbleDots[i + 1].dx) / 2;
        var dy = (this.drawAbleDots[i].dy + this.drawAbleDots[i + 1].dy) / 2;
        Distance tempDist = Distance(dx, dy + 10, distance, true);
        temp.add(tempDist);
      }
    }
    this.zHeightVariationList = temp;
  }

  void removeDotIndex(int index) {
    allDots.removeAt(index);
    drawAbleDots.removeAt(index);
    calculateAverageY();
    calculateDegree();
    generateNewDistances(true);
  }

  void removeDot(Dot dot) {
    allDots.remove(dot);
    recalculateDrawable();
    generateNewDistances(true);
    if (allDots.length > 1) {
      calculateAverageY();
      calculateDegree();
    }
  }

  void updateDot(Dot dot) {
    final sameDot = allDots.firstWhere((element) => element.id == dot.id);
    sameDot.updateCoord(dot);
    recalculateDrawable();
    generateNewDistances(false);
    if (allDots.length > 1) {
      calculateAverageY();
      calculateDegree();
    }
  }

  void setPaintColor(Color color) {
    graphPaint.color = color;
  }

  void calculateDegree() {
    if (allDots.length > 1) {
      var first = allDots[0];
      var last = allDots[allDots.length - 1];
      var degree90 = Dot(last.dx, first.dy);
      var a2plusB2 =
          first.distanceFromDotPow(degree90) + first.distanceFromDotPow(last);
      var c2 = degree90.distanceFromDotPow(last);
      var ab2x =
          2 * first.distanceFromDot(last) * first.distanceFromDot(degree90);
      totalDegree = acos((a2plusB2 - c2) / ab2x) * 180 / pi;
    }
  }

  void addMultipleDots(List<Dot> dots) {
    allDots.addAll(dots);
    this.calculateMetadata();
  }

  void clear() {
    allDots = [];
    drawAbleDots = [];
    totalDegree = 0;
    averageY = 0;
    averageDrawY = 0;
  }

  void reset() {
    this.sliderX = 10;
    this.sliderY = 10;
    this.scale = 10;

    if (this.drawAbleDots.length > 0) {
      this.calculateInitialOffset();
    }
  }

  void calculateAverageY() {
    if (this.allDots.length > 0) {
      averageY = this.allDots.map((m) => m.dy).reduce((a, b) => a + b) /
          this.allDots.length;
    } else {
      averageY = 0;
    }
  }

  void calculateAverageDrawY() {
    if (this.drawAbleDots.length > 0) {
      averageDrawY =
          this.drawAbleDots.map((m) => m.dy).reduce((a, b) => a + b) /
              this.drawAbleDots.length;
    } else {
      averageDrawY = 0;
    }
  }

  void updateOffset(double offsetX, double offsetY, double scale) {
    if (allDots.length > 1) {
      this.movableScale = (scale - 1);
      this.movableOffsetX = offsetX;
      this.movableOffsetY = offsetY;
      recalculateDrawable();
      generateNewDistances(true);
    }
    return;
  }

  void updateSlider({double? sliderX, double? sliderY}) {
    if (sliderX != null) {
      this.sliderX = sliderX;
    }
    if (sliderY != null) {
      this.sliderY = sliderY;
    }

    recalculateDrawable();
    generateNewDistances(true);
  }

  void updateMainAxis(String value) {
    this.allDots.forEach((element) {
      element.axis = value;
    });
    this.drawAbleDots.forEach((element) {
      element.axis = value;
    });
    calculateMetadata();
  }

  List<Dot> calculateOnDrawPointList(Dot point) {
    Dot min = this.drawAbleDots[0];
    Dot max = this.drawAbleDots[this.drawAbleDots.length - 1];
    if (this.drawAbleDots.length > 1 &&
        point.dx >= min.dx &&
        point.dx <= max.x) {
      int minIndex = 0;

      /// Get points what the dot betwwen
      this.drawAbleDots.asMap().forEach((i, x) {
        if (x.dx > min.dx && x.dx < point.dx) {
          min = x;
          minIndex = i;
        } else if (x.dx < max.dx && x.dx > point.dx) {
          max = x;
        }
      });

      var result = Dot.getYProportion3Dots(min, relative: point, absolute: max);
      var pointToCanvas = Dot(point.x, result);
      var divider = Dot.getVectorRelativeProportion(max,
          relative: pointToCanvas, absolute: min);
      var pointToShow = pointOnLineBetweenDots(minIndex, divider);
      return [pointToCanvas, pointToShow];
    }
    return [];
  }

  Dot pointOnLineBetweenDots(int minMax, Dot divider) {
    var min = allDots[minMax];
    var max = allDots[minMax + 1];

    //Get coordinates aligned by drawing
    var coordXAxisOnCanvas = -(((max.dx - min.dx) /
            (divider.x.isNaN || divider.x == 0 ? 1 : divider.x)) -
        min.dx);
    var coordYAxisOnCanvas = -(((max.dy - min.dy) /
            (divider.y.isNaN || divider.y == 0 ? 1 : divider.y)) -
        min.dy);

    /// Calculate remaining coordinate using percentage of others
    var total = Dot.distanceBetweenDots(min, max);
    var rel = Dot.distanceBetweenDots(
        min, Dot(coordXAxisOnCanvas, coordYAxisOnCanvas));
    var div = rel / total;
    if (max.axis == "XZ") {
      var yd = min.y + (max.y - min.y) * div;
      return Dot.dzParameter(coordXAxisOnCanvas, yd, coordYAxisOnCanvas);
    } else if (max.axis == "XY") {
      var zd = min.z + (max.z - min.z) * div;
      return Dot.dzParameter(coordXAxisOnCanvas, coordYAxisOnCanvas, zd);
    } else {
      var xd = min.x + (max.x - min.x) * div;
      return Dot.dzParameter(xd, coordXAxisOnCanvas, coordYAxisOnCanvas);
    }
  }

  List<Dot> pointsToDrawX() {
    List<Dot> newPoints = [];
    drawAbleDots.forEach((element) {
      newPoints.addAll(element.createXDots());
    });
    return newPoints;
  }
}
