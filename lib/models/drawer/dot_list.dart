import 'dart:math';
import 'dart:ui';

import 'package:gamr/models/database/points.dart';
import 'package:gamr/models/drawer/area_mode.dart';
import 'package:gamr/models/drawer/distance.dart';
import 'package:gamr/models/drawer/point.dart';
import 'package:gamr/models/drawer/two_dot_mode.dart';

class DotList {
  /// List containing real dots
  List<Dot> allDots = [];

  /// List for drawable dots. AUTOGENERATED
  List<Dot> drawAbleDots = [];

  /// List for distance dots. AUTOGENERATED
  List<Distance> distances = [];

  /// List for distance dots 3D. AUTOGENERATED
  List<Distance> distances3D = [];

  /// List for height variation. AUTOGENERATED
  List<Distance> zHeightVariationList = [];

  List<Dot> selectedPoint = [];

  TwoDotMode twoDotMode = TwoDotMode();
  AreaMode areaMode = AreaMode();

  bool isCanvasMoving = false;

  double totalDegree = 0;
  double averageY = 0;
  double averageDrawY = 0;
  Paint graphPaint = Paint();

  double offsetX = 0;
  double offsetY = 0;

  double movableScale = 0;
  double scale = 10;

  double movableOffsetX = 0;
  double movableOffsetY = 0;

  double sliderX = 10;
  double sliderY = 10;

  void setNewFixOffset() {
    final scale = getScale();
    offsetX -= movableOffsetX / (sliderX / 10 * scale);
    offsetY -= movableOffsetY / (sliderX / 10 * scale);
    this.scale += movableScale;
    movableOffsetX = 0;
    movableOffsetY = 0;
  }

  double getXOffset() {
    return offsetX - movableOffsetX;
  }

  List<DBPoint> dotsToDBPoint() {
    return allDots
        .map((e) => DBPoint(x: e.x, y: e.y, z: e.z, name: e.name, rank: e.rank))
        .toList();
  }

  double getScale() {
    return pow(1.4, scale + movableScale).toDouble();
  }

  double getYOffset() {
    return offsetY - movableOffsetY;
  }

  void addDot(Dot point) {
    allDots.add(point);
    calculateMetadata();
  }

  void calculateMetadata() {
    calculateAverageY();
    recalculateDrawable();
    calculateDegree();
    generateNewDistances(false);
    if (drawAbleDots.length < 3 && drawAbleDots.isNotEmpty) {
      calculateInitialOffset();
    }
  }

  void calculateInitialOffset() {
    if (allDots.isNotEmpty) {
      offsetY = allDots[0].dy + 5;
      offsetX = -allDots[0].dx + 5;
      recalculateDrawable();
    }
  }

  void recalculateDrawable() {
    if (allDots.isNotEmpty) {
      final scale = getScale();
      drawAbleDots = allDots
          .map((x) => Dot(
              (x.dx + offsetX) * sliderX / 10 * scale - movableOffsetX,
              (-x.dy + offsetY) * sliderY / 10 * scale - movableOffsetY))
          .toList();
    }
    calculateAverageDrawY();
  }

  void generateNewDistances(bool useDistance) {
    final List<Distance> temp = [];
    final List<Distance> temp3D = [];
    for (var i = 0; i < allDots.length - 1; i++) {
      double distance = 0;
      double distance3D = 0;
      if (!useDistance || distances.isEmpty) {
        distance = allDots[i].distanceFromDot(allDots[i + 1]);
        distance3D = allDots[i].distanceFromDot3D(allDots[i + 1]);
      } else {
        distance = distances[i].distance;
        distance3D = distances3D[i].distance;
      }
      final dx = (drawAbleDots[i].dx + drawAbleDots[i + 1].dx) / 2;
      final dy = (drawAbleDots[i].dy + drawAbleDots[i + 1].dy) / 2;
      final Distance tempDist = Distance(dx, dy, distance, true);
      final Distance tempDist3D = Distance(dx, dy, distance3D, true);
      temp.add(tempDist);
      temp3D.add(tempDist3D);
    }
    distances = temp;
    distances3D = temp3D;
    generateHeightVariationList();
  }

  void generateHeightVariationList() {
    final List<Distance> temp = [];
    for (var i = 0; i < allDots.length - 1; i++) {
      double distance = 0;
      if (distances.length > 1) {
        distance = allDots[i].z - allDots[i + 1].z;
        final dx = (drawAbleDots[i].dx + drawAbleDots[i + 1].dx) / 2;
        final dy = (drawAbleDots[i].dy + drawAbleDots[i + 1].dy) / 2;
        final Distance tempDist = Distance(dx, dy + 10, distance, true);
        temp.add(tempDist);
      }
    }
    zHeightVariationList = temp;
  }

  void removeDotIndex(int index) {
    allDots.removeAt(index);
    drawAbleDots.removeAt(index);
    calculateAverageY();
    calculateDegree();
    generateNewDistances(true);
  }

  void removeDot(Dot dot) {
    allDots.remove(dot);
    recalculateDrawable();
    generateNewDistances(true);
    if (allDots.length > 1) {
      calculateAverageY();
      calculateDegree();
    }
  }

  void updateDot(Dot dot) {
    final sameDot = allDots.firstWhere((element) => element.id == dot.id);
    sameDot.updateCoord(dot);
    recalculateDrawable();
    generateNewDistances(false);
    if (allDots.length > 1) {
      calculateAverageY();
      calculateDegree();
    }
  }

  void setPaintColor(Color color) {
    graphPaint.color = color;
  }

  void calculateDegree() {
    if (allDots.length > 1) {
      final first = allDots[0];
      final last = allDots[allDots.length - 1];
      final degree90 = Dot(last.dx, first.dy);
      final a2plusB2 =
          first.distanceFromDotPow(degree90) + first.distanceFromDotPow(last);
      final c2 = degree90.distanceFromDotPow(last);
      final ab2x =
          2 * first.distanceFromDot(last) * first.distanceFromDot(degree90);
      totalDegree = acos((a2plusB2 - c2) / ab2x) * 180 / pi;
    }
  }

  void addMultipleDots(List<Dot> dots) {
    allDots.addAll(dots);
    calculateMetadata();
  }

  void clear() {
    allDots = [];
    drawAbleDots = [];
    totalDegree = 0;
    averageY = 0;
    averageDrawY = 0;
  }

  void reset() {
    sliderX = 10;
    sliderY = 10;
    scale = 10;

    if (drawAbleDots.isNotEmpty) {
      calculateInitialOffset();
    }
  }

  void calculateAverageY() {
    if (allDots.isNotEmpty) {
      averageY = allDots.map((m) => m.dy).reduce((a, b) => a + b) /
          allDots.length;
    } else {
      averageY = 0;
    }
  }

  void calculateAverageDrawY() {
    if (drawAbleDots.isNotEmpty) {
      averageDrawY =
          drawAbleDots.map((m) => m.dy).reduce((a, b) => a + b) /
              drawAbleDots.length;
    } else {
      averageDrawY = 0;
    }
  }

  void updateOffset(double offsetX, double offsetY, double scale) {
    if (allDots.length > 1) {
      movableScale = scale - 1;
      movableOffsetX = offsetX;
      movableOffsetY = offsetY;
      recalculateDrawable();
      generateNewDistances(true);
    }
    return;
  }

  void updateSlider({double? sliderX, double? sliderY}) {
    if (sliderX != null) {
      this.sliderX = sliderX;
    }
    if (sliderY != null) {
      this.sliderY = sliderY;
    }

    recalculateDrawable();
    generateNewDistances(true);
    refreshDrawArea();

    if (twoDotMode.isFull) {
      setDividerBetweenSelectedPoints2D();
    }
  }

  void updateMainAxis(String value) {
    allDots.forEach((element) {
      element.axis = value;
    });
    drawAbleDots.forEach((element) {
      element.axis = value;
    });
    calculateMetadata();
  }

  void calculateOnDrawPointList(Dot selectedPoint) {
    const int circleRadius = 10;
    double? minDistance;
    Dot? currentDrawableDot;
    Dot? currentDot;
    //http://csharphelper.com/blog/2014/09/determine-where-a-line-intersects-a-circle-in-c/
    for (var i = 0; i < drawAbleDots.length - 1; i++) {
      final point2 = drawAbleDots[i + 1];
      final point1 = drawAbleDots[i];

      final dx = point2.x - point1.x;
      final dy = point2.y - point1.y;

      final A = dx * dx + dy * dy;
      final B = 2 *
          (dx * (point1.x - selectedPoint.x) +
              dy * (point1.y - selectedPoint.y));
      final C = (point1.x - selectedPoint.x) * (point1.x - selectedPoint.x) +
          (point1.y - selectedPoint.y) * (point1.y - selectedPoint.y) -
          circleRadius * circleRadius;

      final det = B * B - 4 * A * C;
      if (A > 0.000001 && det > 0) {
        var t = (-B + sqrt(det)) / (2 * A);
        final Dot intersection1 = Dot(point1.x + t * dx, point1.y + t * dy);
        t = (-B - sqrt(det)) / (2 * A);
        final Dot intersection2 = Dot(point1.x + t * dx, point1.y + t * dy);
        final Dot finalDot = Dot((intersection1.x + intersection2.x) / 2,
            (intersection1.y + intersection2.y) / 2);
        final calculatedDistance = finalDot.distanceFromDot(selectedPoint);
        final betweenXCoordinates = point1.x < point2.x
            ? finalDot.x > point1.x && finalDot.x < point2.x
            : finalDot.x > point2.x && finalDot.x < point1.x;
        final betweenYCoordinates = point1.y < point2.y
            ? finalDot.y > point1.y && finalDot.y < point2.y
            : finalDot.y > point2.y && finalDot.y < point1.y;
        if ((minDistance == null || calculatedDistance < minDistance) &&
            betweenXCoordinates &&
            betweenYCoordinates) {
          minDistance = calculatedDistance;
          currentDrawableDot = finalDot;
          final tempVecX = point2.x - finalDot.x;

          final firstDot = allDots[i];
          final secondDot = allDots[i + 1];
          final dotVector = [
            secondDot.x - firstDot.x,
            secondDot.y - firstDot.y,
            secondDot.z - firstDot.z,
          ];
          final proportion = tempVecX / dx;
          currentDot = Dot.dzParameter(
              firstDot.x + dotVector[0] * proportion,
              firstDot.y + dotVector[1] * proportion,
              firstDot.z + dotVector[2] * proportion);
        }
      } else if (A > 0.000001 && det == 0) {
        final t = -B / (2 * A);
        final Dot intersection1 = Dot(point1.dx + t * dx, point1.dx + t * dy);
        final point1Distance = intersection1.distanceFromDot(point1);
        final point2Distance = intersection1.distanceFromDot(point2);
        if (minDistance == null ||
            (point1Distance < point2Distance && point1Distance < minDistance)) {
          currentDrawableDot = point1;
          minDistance = point1Distance;
          currentDot = allDots[i];
        }
        if (point1Distance > point2Distance && point2Distance < minDistance) {
          currentDrawableDot = point2;
          minDistance = point2Distance;
          currentDot = allDots[i + 1];
        }
      }
    }
    if (currentDot != null) {
      this.selectedPoint = [currentDrawableDot!, currentDot];
    } else {
      this.selectedPoint = [];
    }
  }

  Dot pointOnLineBetweenDots(int minMax, Dot divider) {
    final min = allDots[minMax];
    final max = allDots[minMax + 1];

    //Get coordinates aligned by drawing
    final coordXAxisOnCanvas = -(((max.dx - min.dx) /
            (divider.x.isNaN || divider.x == 0 ? 1 : divider.x)) -
        min.dx);
    final coordYAxisOnCanvas = -(((max.dy - min.dy) /
            (divider.y.isNaN || divider.y == 0 ? 1 : divider.y)) -
        min.dy);

    /// Calculate remaining coordinate using percentage of others
    final total = Dot.distanceBetweenDots(min, max);
    final rel = Dot.distanceBetweenDots(
        min, Dot(coordXAxisOnCanvas, coordYAxisOnCanvas));
    final div = rel / total;
    if (max.axis == "XZ") {
      final yd = min.y + (max.y - min.y) * div;
      return Dot.dzParameter(coordXAxisOnCanvas, yd, coordYAxisOnCanvas);
    } else if (max.axis == "XY") {
      final zd = min.z + (max.z - min.z) * div;
      return Dot.dzParameter(coordXAxisOnCanvas, coordYAxisOnCanvas, zd);
    } else {
      final xd = min.x + (max.x - min.x) * div;
      return Dot.dzParameter(xd, coordXAxisOnCanvas, coordYAxisOnCanvas);
    }
  }

  List<Dot> pointsToDrawX() {
    final List<Dot> newPoints = [];
    drawAbleDots.forEach((element) {
      newPoints.addAll(element.createXDots());
    });
    return newPoints;
  }

  /// On active line reset selected point
  resetSelectedPoint() {
    selectedPoint = [];
  }

  int nearestDotToSelected(Dot selectedPoint) {
    double minDistance = drawAbleDots[0].distanceFromDot(selectedPoint);
    int dotIndex = 0;
    for (var i = 0; i < drawAbleDots.length; i++) {
      final nextCalculatedDistance =
          drawAbleDots[i].distanceFromDot(selectedPoint);
      if (nextCalculatedDistance < minDistance) {
        minDistance = nextCalculatedDistance;
        dotIndex = i;
      }
    }
    return dotIndex;
  }

  selectDotForAreaCalculation(Dot selectedPoint) {
    final dotIndex = nearestDotToSelected(selectedPoint);
    areaMode.addDotIndex(dotIndex);
    areaMode.addDot(allDots[dotIndex], drawAbleDots[dotIndex]);
    areaMode.calculateArea();
  }

  refreshDrawArea() {
    areaMode.resetDrawable();
    areaMode.dotIndexes.forEach((element) {
      areaMode.addDot(allDots[element], drawAbleDots[element]);
    });
  }

  selectDotForDivider(Dot selectedPoint) {
    final dotIndex = nearestDotToSelected(selectedPoint);
    twoDotMode.setDot(dotIndex, allDots[dotIndex]);
    if (twoDotMode.isFull) {
      setDividerBetweenSelectedPoints2D();
    }
  }

  setDividerDistance(double distance) {
    if (distance > 0) {
      twoDotMode.dividerDistance = distance;
    }
  }

  setDividerBetweenSelectedPoints2D() {
    if (twoDotMode.isFull && twoDotMode.dividerDistance != null) {
      final firstIndex = twoDotMode.selectedDotIndexes[0];
      final secondIndex = twoDotMode.selectedDotIndexes[1];

      final firstDot = allDots[firstIndex];
      final secondDot = allDots[secondIndex];

      final distanceBetweenDots = firstDot.distanceFromDot(secondDot);

      final divider = distanceBetweenDots / twoDotMode.dividerDistance!;
      final possibleDividing = divider.floor();

      if (possibleDividing > 0) {
        final firstDrawDot = drawAbleDots[firstIndex];
        final secondDrawDot = drawAbleDots[secondIndex];

        final drawVector = [
          secondDrawDot.dx - firstDrawDot.dx,
          secondDrawDot.dy - firstDrawDot.dy
        ];

        final dotVector = [
          secondDot.x - firstDot.x,
          secondDot.y - firstDot.y,
          secondDot.z - firstDot.z,
        ];

        twoDotMode.resetPoints();

        for (var i = 0; i < possibleDividing; i++) {
          if (!twoDotMode.continueMode && i > 0) {
            break;
          } else {
            final createdDrawDistanceDot = Dot(
                firstDrawDot.dx + drawVector[0] * ((i + 1) / divider),
                firstDrawDot.dy + drawVector[1] * ((i + 1) / divider));

            final createdDistanceDot = Dot.dzParameter(
                firstDot.x + dotVector[0] * ((i + 1) / divider),
                firstDot.y + dotVector[1] * ((i + 1) / divider),
                firstDot.z + dotVector[2] * ((i + 1) / divider));

            twoDotMode.drawDistanceDots.add(createdDrawDistanceDot);
            twoDotMode.distanceDots.add(createdDistanceDot);
          }
        }
      } else {
        return;
      }
    }
  }
}
